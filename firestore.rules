rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {
    
    // Helper function for supporters validation
    function isValidSupporterUpdate() {
      let supportersDiff = request.resource.data.supporters.diff(resource.data.supporters);
      return supportersDiff.removedKeys().size() == 0 &&
             supportersDiff.changedKeys().size() == 0 &&
             supportersDiff.addedKeys().hasOnly([request.auth.uid]) &&
             supportersDiff.addedKeys().size() <= 1;
    }
    
    // Users - public profile viewing with secure field protection
    match /users/{userId} {
      allow read: if true; // ✅ Public access as intended
      
      // Allow profile updates by owner only
      allow update: if request.auth != null && 
                   request.auth.uid == userId &&
                   // Only allow specific profile fields to be updated
                   request.resource.data.diff(resource.data).affectedKeys()
                     .hasOnly(['bio', 'bannerImage', 'profileImage', 'displayName', 'country', 'username', 'profileCompleted', 'updatedAt']) &&
                   // Protect system fields from tampering
                   request.resource.data.email == resource.data.email &&
                   request.resource.data.createdAt == resource.data.createdAt &&
                   // Enforce username format when present
                   (!('username' in request.resource.data) || 
                    request.resource.data.username.matches('^[a-z0-9]{3,}$'));
      
      // Allow secure counter updates (owner only, incremental only)
      allow update: if request.auth != null &&
                   request.auth.uid == userId &&
                   // Only allow counter fields to be updated
                   request.resource.data.diff(resource.data).affectedKeys()
                     .hasOnly(['campaignsCreated', 'campaignsCount', 'updatedAt']) &&
                   // Protect system fields
                   request.resource.data.email == resource.data.email &&
                   request.resource.data.createdAt == resource.data.createdAt &&
                   // Ensure counters only increase by 1 (prevent manipulation)
                   (!('campaignsCreated' in request.resource.data.diff(resource.data).changedKeys()) ||
                    request.resource.data.campaignsCreated == resource.data.campaignsCreated + 1) &&
                   (!('campaignsCount' in request.resource.data.diff(resource.data).changedKeys()) ||
                    request.resource.data.campaignsCount == resource.data.campaignsCount + 1);
      
      allow create: if request.auth != null && request.auth.uid == userId;
      // Don't allow delete - prevents breaking username mappings
    }
    
    // Usernames - public username checks with format validation  
    match /usernames/{username} {
      allow read: if true; // ✅ Public access for username checking
      allow create: if request.auth != null && 
                   request.auth.uid == request.resource.data.userId &&
                   username.matches('^[a-z0-9]{3,}$'); // Enforce username format
      allow delete: if request.auth != null && request.auth.uid == resource.data.userId;
    }
    
    // Campaigns - public reading with secure usage tracking
    match /campaigns/{campaignId} {
      allow read: if true; // ✅ Public access for guest users
      
      // Allow campaign creation with required fields validation
      allow create: if request.auth != null && 
                   request.auth.uid == request.resource.data.creatorId &&
                   // Validate required fields exist
                   request.resource.data.keys().hasAll(['type', 'title', 'slug', 'imageUrl', 'creatorId']) &&
                   // Validate type is either 'frame' or 'background'
                   request.resource.data.type in ['frame', 'background'];
      
      // Allow campaign owner full control
      allow update, delete: if request.auth != null && request.auth.uid == resource.data.creatorId;
      
      // Allow secure usage tracking by authenticated users
      allow update: if request.auth != null &&
                   // Only allow usage tracking fields
                   request.resource.data.diff(resource.data).affectedKeys()
                     .hasOnly(['usageCount', 'supporters', 'supportersCount', 'updatedAt']) &&
                   // Ensure usageCount only increases by 1
                   request.resource.data.usageCount == resource.data.usageCount + 1 &&
                   // Ensure supportersCount only increases by 0 or 1 (0 if existing supporter, 1 if new)
                   (!('supportersCount' in request.resource.data.diff(resource.data).changedKeys()) ||
                    request.resource.data.supportersCount == resource.data.supportersCount + 1) &&
                   // Use helper function for supporters validation
                   isValidSupporterUpdate();
    }
    
    // Reports - allow creation by anyone, reading/updating by admins only
    match /reports/{reportId} {
      // Allow anyone (including anonymous) to create reports
      allow create: if request.resource.data.keys().hasAll(['campaignId', 'reason']) &&
                   request.resource.data.reason in ['inappropriate', 'spam', 'copyright', 'other'] &&
                   request.resource.data.status == 'pending';
      
      // Only authenticated users can read reports (admin check should be in application layer)
      allow read: if request.auth != null;
      
      // Only authenticated users can update reports (admin check should be in application layer)
      allow update: if request.auth != null;
      
      // No deletion of reports
    }
    
    // All other documents require authentication
    match /{document=**} {
      allow read: if request.auth != null;
    }
  }
}